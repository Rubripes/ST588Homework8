---
title: "ST588 Homework 8"
author: "Matthew Bray"
format: html
editor: visual
---

##HW 8: Basic Modeling Practice
### First order of business...load libraries that are needed for the project:
```{r}
library(readr)
library(tidyverse)
library(lubridate)
library(gganimate)
library(gifski)
```
### Reading Data
We'll read in the data using `readr::read_csv`.
```{r}
data <- read_csv("SeoulBikeData.csv")
```
### EDA
Next, we'll do some basic EDA...

1) Check for missingness by summing columns where the data `is.na`.
```{r}
colSums(is.na(data))
```
It appears there are no missing data.

Next, we'll check the variable (column) types and see if the data make sense (numerical values have a rational mean and other stats), and that categorical variables have unique values.
```{r}
str(data)
```
The data appears "normal", except date is a character and hour appears like it could be a count.  We can check the numeric variables by creating numeric summaries to see if they make sense.  We'll use the `summary()` function to get 5 number summary for numeric values:
```{r}
summary(data)
```
This looks like hour is a real number and the view in the `str()` function output may have been coincidental, but I am still unsure what "hour" is.  We can also look at the character variables to see how many unique values there may be in each category by creating frequency tables.
```{r}
table(data$Seasons)
```
Seasons look reasonable, there are the four standard seasons in roughly equal proportion.

```{r}
table(data$Holiday)
```
Holiday also appears reasonable, with the only two logical possibilities, and with fewer holidays than non-holidays, which is sadly the reality.

```{r}
data2 <- data |>
  rename("functioningDay" = "Functioning Day")

table(data2$functioningDay)
```
This seems to make sense, there are two classes.

We'll next conver the date from a character variable to a date using `lubridate()`, turn the other character variables into factors, and rename all the variables for consistent naming.  We'll use the `lubridate` package and the `dplyr` package.
```{r}
names(data)

#rename using names()fuction to help with renaming non-standard variables
names(data) <- c("date",
                 "rentedBikeCount",
                 "hour",
                 "tempC",
                 "humidityPct",
                 "windM_S",
                 "vis",
                 "dewPointTempC",
                 "solarRadiation",
                 "rainfallmm",
                 "snowfallcm",
                 "seasons",
                 "holiday",
                 "functioningDay")
#coerce date from chr to date formt using lubridate::dmy
data$date <- dmy(data$date)

#create list of variables to coerce to factors
factors <- c("seasons", "holiday", "functioningDay")
#coerce to factor using list above
data3 <-data |>
  mutate_at(factors, factor)
#check to see conversions were successful
head(data3)
```
The variable transformations were successful.  Now, we'll move on with some more exploration of this updated data.

##Summary Statistics Across Bike Rental Count and Categorical Variables:
We'll start by grouping by `rentedBikeCount`:
```{r}
seasonsStat <- data3 |>
  group_by(seasons) |>
  summarise(
    count = n(),
    mean = mean(rentedBikeCount),
    sd = sd(rentedBikeCount),
    min = min(rentedBikeCount),
    max = max(rentedBikeCount)
  )
seasonsStat
```
These statistics are a little difficult to make sense of because they represent the number of bikes rented per certain hour of each date within the corresponding season, these values do not represent the average number of bikes rented per season.  However, it is intuitive that more bikes are rented per certain hour on a given date during the summer vs. winter, as the weather is typically more conducive to bike riding in the summer, thereby increasing demand.

Are hours `1:24`?
```{r}
unique(data$hour)
```
Close...`0:23`.  This looks like a 24 hour clock for tabulating a statndardized time window for rentals each day.

Let's look at similar summary stats for other categorical groupings, starting with Holiday...
```{r}
holidayStat <- data3 |>
  group_by(holiday) |>
  summarise(
    count = n(),
    mean = mean(rentedBikeCount),
    sd = sd(rentedBikeCount),
    min = min(rentedBikeCount),
    max = max(rentedBikeCount)
  )
holidayStat
```
...then Functioning Day:
```{r}
funDayStat <- data3 |>
  group_by(functioningDay) |>
  summarise(
    count = n(),
    mean = mean(rentedBikeCount),
    sd = sd(rentedBikeCount),
    min = min(rentedBikeCount),
    max = max(rentedBikeCount)
  )
funDayStat
```
It looks like no bikes were rented on Non-functional days.  I'm still not sure what a "Non-Functional" Day is, but we can remove the Non-Functioning Days from the dataset, since they don't provide much useful information other than people don't rent bikes on non-functional days.

We'll subset the data to remove `"functioningDay" == "No"`.
```{r}
data4 <- data3 |>
  filter(!functioningDay == "No")
#check to make sure the correct values were removed:
funDayStatYes <- data4 |>
  group_by(functioningDay) |>
  summarise(
    count = n(),
    mean = mean(rentedBikeCount),
    sd = sd(rentedBikeCount),
    min = min(rentedBikeCount),
    max = max(rentedBikeCount)
  )
funDayStatYes
```
Ok, good news.  The stats for `"functioningDay"` remain the same after subsetting.

Next, we'll summarize across the hours so that each day has one observation associated with it.
```{r}
data5 <- data4 |>
  group_by(date, seasons, holiday) |>
  summarise(n=n(),
            sumCount = sum(rentedBikeCount),
            sumRain = sum(rainfallmm),
            sumSnow = sum(snowfallcm),
            meanCount = mean(rentedBikeCount),
            meanRain = mean(rainfallmm),
            meanSnow = mean(snowfallcm))
data5
```
We'll take this new summary dataset and calculate the same summary stats as before.  By Season:
```{r}
seasonsStat1 <- data5 |>
  group_by(seasons) |>
  summarise(
    count = n(),
    mean = mean(sumCount),
    sd = sd(sumCount),
    min = min(sumCount),
    max = max(sumCount)
  )
seasonsStat1
```
This must be a large city...36149 rentals in a single day is a lot of bikes!


By Holiday:
```{r}
holidayStat1 <- data5 |>
  group_by(holiday) |>
  summarise(
    count = n(),
    mean = mean(sumCount),
    sd = sd(sumCount),
    min = min(sumCount),
    max = max(sumCount)
  )
holidayStat1
```
There is a large difference in sample size between Holiday and No Holiday.

### EDA Graphics
Let's create some plots to help visualize the data.
```{r}
#plot snow vs. rain and color points by season.
ggplot(data5, aes(sumRain, sumSnow, size = sumCount, colour = seasons)) +
  geom_point(alpha = 0.7, show.legend = TRUE) +
  scale_size(range = c(2, 12)) +
  facet_wrap(~holiday) +
  # Here comes the gganimate specific bits
  labs(title = 'Rain and Snow Impacts on Daily Rental Volume', x = 'Sum Daily Rain', y = 'Sum Daily Snow') 
```
It seems that snow does have a lot of appeal for bike riding.  Rain appears to be tolerable, but the decreasing size of the rental counts relative to increasing total daily rainfall makes sense...people just don't really want to get soaked while riding.  There also are not many days where it both rains and snows.  Snow seems to have the biggest impact on rental numbers in this visualization, and the trends hold between holidays and non-holidays.

Next, let's look weather totals vs. rental volume seperately by rain or snow:
```{r}
#plot snow vs. rain and color points by season.
ggplot(data5, aes(sumRain, sumCount, colour = seasons)) +
  geom_point(alpha = 0.7, show.legend = TRUE) +
  geom_smooth(method = "LM", fill = NA) +
  scale_size(range = c(2, 12)) +
  facet_wrap(~holiday) +
  # Here comes the gganimate specific bits
  labs(title = 'Rain Impacts on Daily Rental Volume', x = 'Sum Daily Rain', y = 'Daily Rental Volume') 
```








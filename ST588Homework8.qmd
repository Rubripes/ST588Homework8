---
title: "ST588 Homework 8"
author: "Matthew Bray"
format: html
editor: visual
code-overflow: wrap
---

##HW 8: Basic Modeling Practice
### First order of business...load libraries that are needed for the project:
```{r}
library(readr)
library(tidyverse)
library(lubridate)
library(gganimate)
library(tidymodels)
```
### Reading Data
We'll read in the data using `readr::read_csv`.
```{r}
data <- read_csv("SeoulBikeData.csv")
```
### EDA
Next, we'll do some basic EDA...

1) Check for missingness by summing columns where the data `is.na`.
```{r}
colSums(is.na(data))
```
It appears there are no missing data.

Next, we'll check the variable (column) types and see if the data make sense (numerical values have a rational mean and other stats), and that categorical variables have unique values.
```{r}
str(data)
```
The data appears "normal", except date is a character and hour appears like it could be a count.  We can check the numeric variables by creating numeric summaries to see if they make sense.  We'll use the `summary()` function to get 5 number summary for numeric values:
```{r}
summary(data)
```
This looks like hour is a real number and the view in the `str()` function output may have been coincidental, but I am still unsure what "hour" is.  We can also look at the character variables to see how many unique values there may be in each category by creating frequency tables.
```{r}
table(data$Seasons)
```
Seasons look reasonable, there are the four standard seasons in roughly equal proportion.

```{r}
table(data$Holiday)
```
Holiday also appears reasonable, with the only two logical possibilities, and with fewer holidays than non-holidays, which is sadly the reality.

```{r}
data2 <- data |>
  rename("functioningDay" = "Functioning Day")

table(data2$functioningDay)
```
This seems to make sense, there are two classes.

We'll next conver the date from a character variable to a date using `lubridate()`, turn the other character variables into factors, and rename all the variables for consistent naming.  We'll use the `lubridate` package and the `dplyr` package.
```{r}
names(data)

#rename using names()fuction to help with renaming non-standard variables
names(data) <- c("date",
                 "rentedBikeCount",
                 "hour",
                 "tempC",
                 "humidityPct",
                 "windM_S",
                 "vis",
                 "dewPointTempC",
                 "solarRadiation",
                 "rainfallmm",
                 "snowfallcm",
                 "seasons",
                 "holiday",
                 "functioningDay")
#coerce date from chr to date formt using lubridate::dmy
data$date <- dmy(data$date)

#create list of variables to coerce to factors
factors <- c("seasons", "holiday", "functioningDay")
#coerce to factor using list above
data3 <-data |>
  mutate_at(factors, factor)
#check to see conversions were successful
head(data3)
```
The variable transformations were successful.  Now, we'll move on with some more exploration of this updated data.

##Summary Statistics Across Bike Rental Count and Categorical Variables:
We'll start by grouping by `rentedBikeCount`:
```{r}
seasonsStat <- data3 |>
  group_by(seasons) |>
  summarise(
    count = n(),
    mean = mean(rentedBikeCount),
    sd = sd(rentedBikeCount),
    min = min(rentedBikeCount),
    max = max(rentedBikeCount)
  )
seasonsStat
```
These statistics are a little difficult to make sense of because they represent the number of bikes rented per certain hour of each date within the corresponding season, these values do not represent the average number of bikes rented per season.  However, it is intuitive that more bikes are rented per certain hour on a given date during the summer vs. winter, as the weather is typically more conducive to bike riding in the summer, thereby increasing demand.

Are hours `1:24`?
```{r}
unique(data$hour)
```
Close...`0:23`.  This looks like a 24 hour clock for tabulating a statndardized time window for rentals each day.

Let's look at similar summary stats for other categorical groupings, starting with Holiday...
```{r}
holidayStat <- data3 |>
  group_by(holiday) |>
  summarise(
    count = n(),
    mean = mean(rentedBikeCount),
    sd = sd(rentedBikeCount),
    min = min(rentedBikeCount),
    max = max(rentedBikeCount)
  )
holidayStat
```
...then Functioning Day:
```{r}
funDayStat <- data3 |>
  group_by(functioningDay) |>
  summarise(
    count = n(),
    mean = mean(rentedBikeCount),
    sd = sd(rentedBikeCount),
    min = min(rentedBikeCount),
    max = max(rentedBikeCount)
  )
funDayStat
```
It looks like no bikes were rented on Non-functional days.  I'm still not sure what a "Non-Functional" Day is, but we can remove the Non-Functioning Days from the dataset, since they don't provide much useful information other than people don't rent bikes on non-functional days.

We'll subset the data to remove `"functioningDay" == "No"`.
```{r}
data4 <- data3 |>
  filter(!functioningDay == "No")
#check to make sure the correct values were removed:
funDayStatYes <- data4 |>
  group_by(functioningDay) |>
  summarise(
    count = n(),
    mean = mean(rentedBikeCount),
    sd = sd(rentedBikeCount),
    min = min(rentedBikeCount),
    max = max(rentedBikeCount)
  )
funDayStatYes
```
Ok, good news.  The stats for `"functioningDay"` remain the same after subsetting.

Next, we'll summarize across the hours so that each day has one observation associated with it.
```{r}
data5 <- data4 |>
  group_by(date, seasons, holiday) |>
  summarise(sumCount = sum(rentedBikeCount),
            sumRain = sum(rainfallmm),
            sumSnow = sum(snowfallcm),
            meanTemp = mean(tempC),
            meanHumidity = mean(humidityPct),
            meanWind = mean(windM_S),
            meanVis = mean(vis),
            meanDP_C = mean(dewPointTempC),
            meanSR = mean(solarRadiation))
data5
```
We'll take this new summary dataset and calculate the same summary stats as before.  By Season:
```{r}
seasonsStat1 <- data5 |>
  group_by(seasons) |>
  summarise(
    count = n(),
    mean = mean(sumCount),
    sd = sd(sumCount),
    min = min(sumCount),
    max = max(sumCount)
  )
seasonsStat1
```
This must be a large city...36149 rentals in a single day is a lot of bikes!


By Holiday:
```{r}
holidayStat1 <- data5 |>
  group_by(holiday) |>
  summarise(
    count = n(),
    mean = mean(sumCount),
    sd = sd(sumCount),
    min = min(sumCount),
    max = max(sumCount)
  )
holidayStat1
```
There is a large difference in sample size between Holiday and No Holiday.

### EDA Graphics
Let's create some plots to help visualize the data.
```{r}
#plot snow vs. rain and color points by season.
ggplot(data5, aes(sumRain, sumSnow, size = sumCount, colour = seasons)) +
  geom_point(alpha = 0.7, show.legend = TRUE) +
  scale_size(range = c(2, 12)) +
  facet_wrap(~holiday) +
  # Here comes the gganimate specific bits
  labs(title = 'Rain and Snow Impacts on Daily Rental Volume', x = 'Sum Daily Rain', y = 'Sum Daily Snow') 
```
It seems that snow does not have a lot of appeal for bike riding.  Rain appears to be tolerable, but the decreasing size of the rental counts relative to increasing total daily rainfall makes sense...people just don't really want to get soaked while riding.  There also are not many days where it both rains and snows.  Snow seems to have the biggest impact on rental numbers in this visualization, and the trends hold between holidays and non-holidays.

Next, let's look weather totals vs. rental volume seperately by rain or snow:
```{r}
#plot snow vs. rain and color points by season.
ggplot(data5, aes(sumRain, sumCount, colour = seasons)) +
  geom_point(alpha = 0.7, show.legend = TRUE) +
  scale_size(range = c(2, 12)) +
  # Here comes the gganimate specific bits
  labs(title = 'Rain Impacts on Daily Rental Volume', x = 'Sum Daily Rain', y = 'Daily Rental Volume') 
```
There is an apparent relationship between season and rental volume, with the warmer seasons (and dryer seasons/days) tending to exhibit the highest rental volume.

What about snow only?
```{r}
ggplot(data5, aes(sumSnow, sumCount, colour = seasons)) +
  geom_point(alpha = 0.7, show.legend = TRUE) +
  scale_size(range = c(2, 12)) +
  labs(title = 'Snow Impacts on Daily Rental Volume', x = 'Sum Daily Snow', y = 'Daily Rental Volume') 
```
It obviously doesn't snow much in the summer....
Appreciable snowfall depresses the rental volume quite a lot!

## Split the Data
We'll split the data into a training and test set (75/25).  We'll use the `strata` argument to stratify the split on the `seasons` variable.

First, we'll use the `initial_split()`, `training()`, and `testing()` functions to create the splits:
```{r}
set.seed(10)
rental_split <- initial_split(data5, prop = 0.75, strata ="seasons")
rental_train <- training(rental_split)
rental_test <- testing(rental_split)
rental_train
```
263/353 = ~ 75%, so that looks like we successfully created the right proportions for our training/test datasets.

263 rows in the training dataset, which is not evenly divisible by 10.  Each fold will have 26 observations, and one fold with have 29.
```{r}
size_fold <- floor(nrow(rental_train)/10)
size_fold
```
Next, we'll set a seed and randomly sample the folds into a list.
```{r}
set.seed(10)
random_indices <- sample(1:nrow(rental_train), size = nrow(rental_train), replace=FALSE)
head(random_indices)
```
We can see above the first index of each fold.

Next, we'll create a list in which to save our folds, then cycle through the random indices vector to place the observations from each fold in the list accordingly.

```{r}
folds <- list()

for(i in 1:10){
  if (i<10) {
    fold_index <- seq(from = (i-1)*size_fold + 1, to = i*size_fold, by=1)
    folds[[i]] <- rental_train[random_indices[fold_index], ]
  } else {
    fold_index <- seq(from = (i-1)*size_fold +1, to=length(random_indices), by =1)
    folds[[i]] <- rental_train[random_indices[fold_index], ]
  }
}

#check out the first fold:
folds[[1]]
```

Let's check out the 10th fold...does it contain 29 observations?
```{r}
folds[[10]]
```
Yes!  There are 29 observations in Fold #10!

##Fitting MLR Models
We'll create 3 recipes to preprocess the data...

###Recipe 1
We'll change the `role` of date, create a weekday/weekend factor variable from the date, standardize the numberic variables, and create dummy variables for `seasons`, `holiday`, and the new variables.
```{r}
bike_rec1 <- 
  recipe(sumCount ~ ., data=rental_train) %>%
  update_role(date, new_role = "ID") %>%
  step_mutate("date" = weekdays(date)) %>%
  step_mutate("date" = factor(if_else(date %in% c("Saturday", "Sunday"), "weekend", "weekday"))) %>%
  #scale the numerical data by normalizing to max value
  #step_mutate("normRain" = "sumRain"/!!max("sumRain"),
  #       "normSnow" = "sumSnow"/!!max("sumSnow"),
  #       "normTemp" = "meanTemp"/!!max("meanTemp"),
  #       "normMeanHumidity" = "meanHumidity"/!!max("meanHumidity"),
  #       "normMeanWind" = "meanWind"/!!max("meanWind"),
  #       "normMeanVis" = "meanVis"/!!max("meanVis"),
  #       "normMeanDP_C" = "meanDP_C"/!!max("meanDP_C"),
  #       "normMeanSR" = "meanSR"/!!max("meanSR"),
  #       keep_original_cols=FALSE) %>%
  step_dummy(all_nominal_predictors()) %>%
  step_normalize(starts_with(c("sum", "mean")), -all_date_predictors(), -all_outcomes()) %>%
  prep(training=rental_train) %>%
  bake(rental_train)

bike_rec1
```

We'll next create the same recipe, with interaction terms between seasons and holiday, seasons and temp, and temp and rainfall.
```{r}
bike_rec2 <- 
  recipe(sumCount ~ ., data=rental_train) %>%
  update_role(date, new_role = "ID") %>%
  step_mutate("date" = weekdays(date)) %>%
  step_mutate("date" = factor(if_else(date %in% c("Saturday", "Sunday"), "weekend", "weekday"))) %>%
  #scale the numerical data by normalizing to max value
  #step_mutate("normRain" = "sumRain"/!!max("sumRain"),
  #       "normSnow" = "sumSnow"/!!max("sumSnow"),
  #       "normTemp" = "meanTemp"/!!max("meanTemp"),
  #       "normMeanHumidity" = "meanHumidity"/!!max("meanHumidity"),
  #       "normMeanWind" = "meanWind"/!!max("meanWind"),
  #       "normMeanVis" = "meanVis"/!!max("meanVis"),
  #       "normMeanDP_C" = "meanDP_C"/!!max("meanDP_C"),
  #       "normMeanSR" = "meanSR"/!!max("meanSR"),
  #       keep_original_cols=FALSE) %>%
  step_dummy(all_nominal_predictors()) %>%
  step_normalize(starts_with(c("sum", "mean")), -all_date_predictors(), -all_outcomes()) %>%
  step_interact(terms = ~ starts_with("seasons"):starts_with("holiday") + starts_with("seasons"):meanTemp + meanTemp:sumRain) %>%
  prep(training=rental_train) %>%
  bake(rental_train)

bike_rec2
```






